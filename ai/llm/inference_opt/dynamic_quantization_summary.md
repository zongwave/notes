
# 动态量化（Dynamic Quantization）概述

## 📌 什么是动态量化？

动态量化是一种**在模型推理阶段将浮点权重或激活压缩为低位宽格式**（如 INT8 或 FP8）的方法，旨在减少内存占用、加速计算、提升能效，特别适用于部署到硬件加速器（如 Gaudi HPU、TPU、ARM 等）上。

与静态量化不同，动态量化：
- 不需要提前为每一层收集统计分布
- 可以在推理时**动态地估算量化参数（scale、zero-point 或 exponent）**

---

## ⚙️ 动态量化的流程

### 1. 收集张量统计信息
- 计算张量中值的范围：`[min, max]`
- 对于 FP8，还需记录指数范围或最大绝对值

### 2. 估算量化参数
- **INT8 格式**：估算 scale 和 zero_point
  ```math
  \text{scale} = \frac{\text{max} - \text{min}}{2^n - 1}
  \quad
  \text{zero\_point} = \left\lfloor -\frac{\text{min}}{\text{scale}} \right\rfloor
  ```
- **FP8 格式（如 E4M3）**：估算 exponent bias，使数据动态“居中”

### 📌 为什么要“使最大值映射至尾数范围中部”？

在 FP8 中，数值的表示方式为：

```math
x = (-1)^s \times (1 + m \times 2^{-3}) \times 2^{e - \text{bias}}
```

尾数只有 3 位，即最多只能表示 8 个不同值（如 1.0, 1.125, ..., 1.875）。

若最大值在该 exponent 对应的尾数区间中心附近，则整个张量分布能更好地利用有效动态范围，避免截断/溢出。

例如：

- 若张量最大值为 1.2
- 可令 exponent = 0，使其对应尾数约为 1.25（中心值）
- 可近似表示为：`1.2 ≈ 1.25 × 2^0`，误差更小

这就是动态量化“使最大值居中”的策略。

---

### 3. 应用量化和反量化
- 推理过程中将张量转换为低精度数值（INT8 或 FP8）
- 若必要，可在输出处执行反量化还原精度

---

## ✍️ 示例：FP8 动态量化的过程

目标：将浮点张量 `[0.05, 0.2, 1.2]` 量化为 FP8-E4M3

1. 最大值为 1.2 → 选择 exponent = 0，使 1.2 ≈ (1.25 × 2^0)
2. 将每个值拆解为 `mantissa × 2^exponent` 的形式
3. 使用 Round-to-Nearest-Even 保留 3 位尾数

示例：

- `0.2 ≈ 0.8125 × 2^{-2}`，Exponent: -2，偏移7，实际编码指数：`5 (0101)`
- 尾数 0.8125 → 截断为 `0.75`，编码为 `110`
- 最终编码为：`0 0101 110` → `0x2E`

---

## 🎯 优点与挑战

### ✅ 优点
- 显著减少模型大小和显存占用
- 加速推理（特别适用于大模型和边缘设备）
- 支持低功耗部署（适配 AI 芯片）

### ⚠️ 挑战
- 精度下降风险，需控制量化误差
- 对某些不支持低精度的算子仍需 fallback
- 动态计算开销不能过大（需静态图融合优化）

---

## 🛠️ 工程实践建议

| 项目 | 建议 |
|------|------|
| 精度评估 | 在 calibration 或 warm-up 流程中对每层误差进行统计 |
| 量化融合 | 将 MLP、RMSNorm、GEMM 等结构合并执行 |
| 模型适配 | 开启静态推理路径，避免动态张量 shape 干扰 |

---

## 🔚 图示

![LLaMA FP8 动态量化图示](diagram/llama_decoder_fp8_quant_example.png)

---
